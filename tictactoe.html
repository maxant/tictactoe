<html>
<head>
    <script>

//https://en.wikipedia.org/wiki/Tic-tac-toe
// 26,830 possible games
// if X starts, chances are 91 wins, 44 losses, 3 draws

//X always starts => that way computer can use those games to learn from. eg user plays and wins.

//try to win instantly: that way it doesnt need to have all possible games in memory
//     but maybe only fall back to that if it cannot win based on memory?

//its ok to use massive memory. why should machines be based on human learning?!

//TODO does it develop the strategy to go on the corners first, as your more likely to win? it should
//     do, because it tries winning moves which come from shortest games...
//TODO add different strategies?? add eg neural network?
//TODO remove duplicates in history

var model = {};

var HUMAN = "O";
var COMPUTER = "X";

function init(){
    var canvas = document.getElementById("canvas");

    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    document.addEventListener("click", click);

    buildModel();
model.strategy = 'patternRecognition';

    test();
    clear();
    resetStats();

    render();
}

function click(e){

    if(isHit(e, model.clear)){
        clear();
        render();
    }else if(isHit(e, model.resetStats)){
        resetStats();
        render();
    }else if(isHit(e, model.playAutonomously)){
        toggleAuto();
    }else if(isHit(e, model.whoPlaysWhat)){
        toggleWhoPlaysWhat();
    } else if(!model.winner && !model.draw){
        var cell;
        for(i = 0; i < model.board.length; i++){
            for(j = 0; j < model.board[i].length; j++){
                cell = model.board[i][j];
                if(!cell.v && isHit(e, cell)){
                    selectCell(i, j, HUMAN);
                    playAi();
                    return;
                }
            }
        }
    }
}

function toggleWhoPlaysWhat(){
    model.computerStarts = !model.computerStarts;
    clear();
    render();
}

function playAi(){
    checkAndHandleFinished();
    if(!model.winner && !model.draw){
        doAiMove();
        checkAndHandleFinished();
    }
    render();
}

function toggleAuto(){
    model.playAutonomously.active = !model.playAutonomously.active;
    autoPlay();
}

function autoPlay(){
    if(model.playAutonomously.active){
        if(model.winner || model.draw){
            clear();
        }
        moveRandomly(HUMAN);
        playAi();
        setTimeout(autoPlay, 0);
    }
}

function isHit(e, cell){
    return (e.x >= cell.x && e.x <= cell.x + cell.w) &&
            (e.y >= cell.y && e.y <= cell.y + cell.h);
}

//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
}

function doAiMove(){

    // ////////////////////////////
    // search for an instant win
    // ////////////////////////////
    // copy board
    var copyOfBoard = buildEmtpyBoard();
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            copyOfBoard[i][j].v = model.board[i][j].v;
        }
    }
    // attempt all places that are free
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            if(!copyOfBoard[i][j].v){
                copyOfBoard[i][j].v = COMPUTER;
                if(checkFinished(copyOfBoard) === COMPUTER){
                    console.log("found instant win at " + i + "," + j);
                    selectCell(i, j, COMPUTER);
                    model.currentPatternKnown = "No, but found an instant win";
                    return;
                }else{
                    //reset and try next free cell
                    delete copyOfBoard[i][j].v;
                }
            }
        }
    }

    // ////////////////////////////
    // avoid instant loss
    // ////////////////////////////
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            if(!copyOfBoard[i][j].v){
                copyOfBoard[i][j].v = HUMAN;
                if(checkFinished(copyOfBoard) === HUMAN){
                    console.log("found instant lose at " + i + "," + j);
                    selectCell(i, j, COMPUTER);
                    model.currentPatternKnown = "No, but avoiding loss";
                    return;
                }else{
                    //reset and try next free cell
                    delete copyOfBoard[i][j].v;
                }
            }
        }
    }

    // ////////////////////////////////////////////////////
    // No instant win, so use the strategy to get a win
    // ////////////////////////////////////////////////////

    model.currentPatternKnown = "Yes";
    if(model.strategy === 'patternRecognition'){
        // have we seen this pattern? if so, and we had a winning solution, repeat it
        var pattern = buildPattern(model.board);
        var games = model.patternRecognition[pattern];
        if(!games){
            games = [];
        }
        //go through the games and see where we went next at the time
        var placesToLose = [];
        var placesToWin = [];
        var placesToDraw = [];
        for(g = 0; g < games.length; g++){
            var game = games[g];
            var recreatedBoard = buildEmtpyBoard();
            for(h = 0; h < game.h.length; h++){
                var move = game.h[h];
                recreatedBoard[move.i][move.j].v = move.v;
                var patternAtMove = buildPattern(recreatedBoard);
                if(pattern === patternAtMove){
                    if(game.h.length >= h + 1){
                        move = game.h[h + 1];
                        if(game.result === COMPUTER){
                            placesToWin.push(move);
                        }else if(game.result === "draw"){
                            placesToDraw.push(move);
                        }else if(game.result === HUMAN){
                            placesToLose.push(move);
                        }
                        break; //pattern wont be the same if we add moves!
                    }
                }
            }
        }

//TODO if instant win/loss, then just try and win. otherwise avoid losing first!
//     actually, probaby need to compare how quickly win and lose, and react to the one which happens first

        // ////////////////
        // try and win
        // ////////////////

        placesToWin.sort(function(a, b){
            //use totalMoves to choose moves which won with least moves
            return a.totalMoves > b.totalMoves;
        });
        console.log("places to win: " + JSON.stringify(placesToWin.map(function(e){return {i: e.i, j: e.j, w: e.totalMoves};})));
        for(p = 0; p < placesToWin.length; p++){
            var placeToWin = placesToWin[p];
            if(!model.board[placeToWin.i][placeToWin.j].v){
                console.log("selecting cell based on previous win");
                selectCell(placeToWin.i, placeToWin.j, COMPUTER);
                model.currentPatternKnown = "Yes, won";
                return;
            }
        }

        // ////////////////
        // try and draw
        // ////////////////

        console.log("places to draw: " + JSON.stringify(placesToDraw.map(function(e){return {i: e.i, j: e.j};})));
        for(p = 0; p < placesToDraw.length; p++){
            var placeToDraw = placesToDraw[p];
            if(!model.board[placeToDraw.i][placeToDraw.j].v){
                console.log("selecting cell based on previous draw");
                selectCell(placeToDraw.i, placeToDraw.j, COMPUTER);
                model.currentPatternKnown = "Yes, drew";
                return;
            }
        }

        // ////////////////
        // dont lose! we used to try and win first, but its more important to prevent losing! humans do the same.
        // eg you might have won once, but the human missed something. next time they dont, and you want to avoid losing.
        // ////////////////
        console.log("places to lose: " + JSON.stringify(placesToLose.map(function(e){return {i: e.i, j: e.j, w: e.totalMoves};})));
        if(placesToLose.length){
            var boardWithPlacesNotToGo = buildEmtpyBoard();
            for(i = 0; i < model.board.length; i++){
                for(j = 0; j < model.board[i].length; j++){
                    var placesToLoseContainsCurrentCell = false;
                    for(k = 0; k < placesToLose.length; k++){
                        var placeToLose = placesToLose[k];
                        if(i === placeToLose.i && j === placeToLose.j){
                            placesToLoseContainsCurrentCell = true;
                            break;
                        }
                    }
                    if(placesToLoseContainsCurrentCell){
                        boardWithPlacesNotToGo[i][j].doNotGoHere = true;
                    }
                }
            }

            var possibleCellsToGoTo = [];
            var cell;
            for(i = 0; i < model.board.length; i++){
                for(j = 0; j < model.board[i].length; j++){
                    cell = boardWithPlacesNotToGo[i][j];
                    if(cell.doNotGoHere){
                        console.log("places not to go: " + i + "," + j);
                    }else if(!model.board[i][j].v){
                        possibleCellsToGoTo.push(cell);
                    }
                }
            }

            console.log("possible cells to go to: " + JSON.stringify(possibleCellsToGoTo.map(function(e){return {i: e.i, j: e.j};})));
            if(possibleCellsToGoTo.length){
                //now choose a random cell to go to
                var index = getRandomInt(0, possibleCellsToGoTo.length);
                cell = possibleCellsToGoTo[index];
                console.log("selecting cell based on previous losses");
                selectCell(cell.i, cell.j, COMPUTER);
                model.currentPatternKnown = "Yes, lost";
                return;
            }
        }

    }

    model.currentPatternKnown = "No";

    //TODO use for testing:
    //moveDeterministically();
    //console.log("selecting cell deterministically");
    //TODO use for real:
    console.log("selecting cell randomly");
    moveRandomly(COMPUTER);
}

function buildPattern(board) {
    var pattern = "";
    var v;
    for(i = 0; i < board.length; i++){
        for(j = 0; j < board[i].length; j++){
            v = board[i][j].v;
            if(!v){
                v = "-";
            }
            pattern += v + "|";
        }
    }
    return pattern;
}

function moveRandomly(player) {
    var k = 0;
    while(true){
        k++;
        if(k > 10000){
            console.log("failed to move randomly. moving deterministically!");
            if(!moveDeterministically()){
                console.log("unable to move randomly or deterministically");
            }
            break;
        }else{
            var i = getRandomInt(0, 3);
            var j = getRandomInt(0, 3);
            var cell = model.board[i][j];
            if(!cell.v){
                selectCell(i, j, player);
                break;
            }
        }
    }
}

function moveDeterministically() {
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            var cell = model.board[i][j];
            if(!cell.v){
                selectCell(i, j, COMPUTER);
                return {i: i, j: j};
            }
        }
    }
}

function selectCell(i, j, v) {
    if(model.board[i][j].v) throw new Error("cell " + i + "," + j + " is already selected by " + model.board[i][j].v);
    console.log("selecting cell " + i + "," + j + " for " + v);
    model.board[i][j].v = v;
    model.history.push({i: i, j:j, v: v});
    console.log("=================");
}

function checkFinished(board) {
    var i, j, winner;

    function sameNotNullHorizontal(i){
        return board[i][0].v === board[i][1].v &&
               board[i][1].v === board[i][2].v &&
               board[i][0].v;
    }
    for(i = 0; i < board.length; i++){
        if(sameNotNullHorizontal(i)){
            winner = board[i][0].v;
        }
    }

    function sameNotNullVertical(j){
        return board[0][j].v === board[1][j].v &&
               board[1][j].v === board[2][j].v &&
               board[0][j].v;
    }
    for(j = 0; j < board.length; j++){
        if(sameNotNullVertical(j)){
            winner = board[0][j].v;
        }
    }

    if(board[0][0].v &&
        board[0][0].v === board[1][1].v &&
        board[1][1].v === board[2][2].v
    ){
        winner = board[1][1].v;
    }

    if(board[0][2].v &&
        board[0][2].v === board[1][1].v &&
        board[1][1].v === board[2][0].v
    ){
        winner = board[1][1].v;
    }

    if(!winner){
        //check for a draw
        var allFull = true;
        for(i = 0; i < model.board.length; i++){
            for(j = 0; j < model.board[i].length; j++){
                if(!model.board[i][j].v){
                    allFull = false;
                    break;
                }
            }
        }
        if(allFull){
            return "draw";
        }
    }

    return winner;
}

function checkAndHandleFinished(){
    var winner = checkFinished(model.board);
    if(winner){
        model.totalGames++;
        if(winner === "draw"){
            model.draw = true;
            model.stats.draws++;
        } else {
            model.winner = winner;
            handleWin();
        }
    }
}

function handleWin(){

    //remember all moves for the future
    var result = model.draw ? "draw" : model.winner;
    var recreatedBoard = buildEmtpyBoard();
    var pattern = "";
    for(h = 0; h < model.history.length; h++){
        var move = model.history[h];
        move.totalMoves = model.history.length;
        recreatedBoard[move.i][move.j].v = move.v;
        pattern = buildPattern(recreatedBoard);

        if(!model.patternRecognition[pattern]){
            model.patternRecognition[pattern] = [];
        }

        //if we just lost, we want to remove any previous knowledge of wins from this situation
        //because if the player was a weak one / random one, they may have missed a possible win which
        //they could now have. so we need to reset those wins to ensure that we always eliminate
        //possible losses from this position onwards
        model.patternRecognition[pattern] = model.patternRecognition[pattern].filter(function(g){
            return g.result === COMPUTER;
        });

        model.patternRecognition[pattern].push({h: model.history, result: result});
    }

    if(model.winner === "X"){
        model.stats.xWins++;
    }else if(model.winner === "O"){
        model.stats.oWins++;
    }

}

function buildEmtpyBoard() {
    var board = [];
    for(i = 0; i < 3; i++){
        board[i] = [];
        for(j = 0; j < 3; j++){
            board[i][j] = {
                i: i,
                j: j,
                x: 20 * i,
                y: 20 * j,
                w: 20,
                h: 20
            };
        }
    }
    return board;
}

function test(){
    model.board[0][0].v = "X";
    model.board[1][0].v = "X";
    model.board[2][0].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[0][1].v = "X";
    model.board[1][1].v = "X";
    model.board[2][1].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[0][2].v = "X";
    model.board[1][2].v = "X";
    model.board[2][2].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[0][0].v = "X";
    model.board[0][1].v = "X";
    model.board[0][2].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[1][0].v = "X";
    model.board[1][1].v = "X";
    model.board[1][2].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[2][0].v = "X";
    model.board[2][1].v = "X";
    model.board[2][2].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[0][0].v = "X";
    model.board[1][1].v = "X";
    model.board[2][2].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    model.board[0][2].v = "X";
    model.board[1][1].v = "X";
    model.board[2][0].v = "X";
    checkAndHandleFinished();
    assert(model.winner === "X");
    clear();

    // RESET MODEL READY TO PLAY AND LEARN!!!
    model.patternRecognition = {};
    model.totalGames = 0;
}

function assert(b, message){
    if(!b) {
        var msg = "Failed test";
        if(message) msg += ": " + message;
        throw new Error(msg);
    }
}

function buildModel(){

    model.computerStarts = true;

    //the board, including sizes. the value attribute will contain whether X or O selects.
    var i, j;
    model.board = buildEmtpyBoard();

    //the clear button
    model.clear = {
        x: 10,
        y: 80,
        w: 40,
        h: 20
    };

    //the resetStats button
    model.resetStats = {
        x: 60,
        y: 80,
        w: 80,
        h: 20
    };

    //the playAutonomously button
    model.playAutonomously = {
        x: 150,
        y: 80,
        w: 130,
        h: 20
    };

    //the whoPlaysWhat button
    model.whoPlaysWhat = {
        x: 290,
        y: 80,
        w: 80,
        h: 20
    };

    //a place to store moves of the current game
    model.history = [];

    //a place to store pattern recogintion memory
    model.patternRecognition = {};

    model.totalGames = 0;

    resetStats();
}

function resetStats(){
    model.stats = {
        xWins: 0,
        oWins: 0,
        draws: 0
    };
}

function clear(){
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            delete model.board[i][j].v;
        }
    }
    delete model.winner;
    delete model.draw;
    model.history = [];

    if(model.computerStarts){
        COMPUTER = "X";
        HUMAN = "O";
        playAi();
    }else{
        COMPUTER = "O";
        HUMAN = "X";
    }
}

function render(){
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    var i, j, cell, x,y, w, h;

    ctx.font = "14px Arial";
    ctx.fillStyle = "black";
    ctx.strokeStyle = "black";

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(i = 0; i < model.board.length; i++){
        for(j = 0; j < model.board[i].length; j++){
            cell = model.board[i][j];
            ctx.strokeRect(cell.x, cell.y, cell.w, cell.h);
            if(cell.v){
                ctx.strokeText(cell.v, cell.x + 5, cell.y + 15);
            }
        }
    }

    ctx.strokeRect(model.clear.x, model.clear.y, model.clear.w, model.clear.h);
    ctx.strokeText("clear", model.clear.x + 6, model.clear.y + 14);

    ctx.strokeRect(model.resetStats.x, model.resetStats.y, model.resetStats.w, model.resetStats.h);
    ctx.strokeText("reset stats", model.resetStats.x + 6, model.resetStats.y + 14);

    ctx.strokeRect(model.playAutonomously.x, model.playAutonomously.y, model.playAutonomously.w, model.playAutonomously.h);
    ctx.strokeText("play autonomously", model.playAutonomously.x + 6, model.playAutonomously.y + 14);

    ctx.strokeRect(model.whoPlaysWhat.x, model.whoPlaysWhat.y, model.whoPlaysWhat.w, model.whoPlaysWhat.h);
    ctx.strokeText("swap roles", model.whoPlaysWhat.x + 6, model.whoPlaysWhat.y + 14);

    ctx.strokeStyle = "red";
    if(model.winner){
        ctx.strokeText("WON BY " + model.winner, model.clear.x + 6, model.clear.y + 40);
    }else if(model.draw){
        ctx.strokeText("DRAW", model.clear.x + 6, model.clear.y + 40);
    }

    ctx.strokeStyle = "black";
    var xp = (100*(model.stats.xWins)/(model.stats.draws+model.stats.xWins+model.stats.oWins)).toFixed(2);
    var op = (100*(model.stats.oWins)/(model.stats.draws+model.stats.xWins+model.stats.oWins)).toFixed(2);
    ctx.strokeText("X wins: " + model.stats.xWins + " ( " + xp + "%)",
        model.clear.x + 6, model.clear.y + 60);
    ctx.strokeText("O wins: " + model.stats.oWins + " ( " + op + "%)",
        model.clear.x + 6, model.clear.y + 75);
    ctx.strokeText("Draws: " + model.stats.draws, model.clear.x + 6, model.clear.y + 90);
    ctx.strokeText("Total games played: " + model.totalGames, model.clear.x + 6, model.clear.y + 105);
    ctx.strokeText("Pattern known? " + model.currentPatternKnown, model.clear.x + 6, model.clear.y + 120);

    ctx.strokeText("Tic Tac Toe", 100, 20);
    ctx.strokeText("X starts", 100, 35);
    ctx.strokeText("You play '" + HUMAN + "', computer plays '" + COMPUTER + "'.", 100, 50);
    ctx.strokeText("As you play the computer will learn.", 100, 65);
}
    </script>
    <style>
body {
    margin: 0;
    padding: 0;
}
canvas {
    position: absolute;
    overflow: hidden;
    display: block;
}
    </style>
</head>
<body onload="init();">
<canvas id="canvas"></canvas>
</body>
</html>